h
mod$tau
taus <- mod$tau
density_list <- lapply(taus, function(tau) estimateDensity(mod = mod, tau, X = X, h = h, test = test))
test = "rank"
density_list <- lapply(taus, function(tau) estimateDensity(mod = mod, tau, X = X, h = h, test = test))
formula <- make_h0_formula(mod = mod, X = X)
formula
mod<-rq(formula = formula, tau=tau, data = mod$model)
mod
coef(mod)
mod
tau=c(0.1, 0.2)
tau=c(0.1, 0.2)
x<-rnorm(100)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x, tau = tau)
rownames(coef(mod))
coef(mod)
tau=c(0.1)
mod <- rq(y ~ x, tau = tau)
rownames(coef(mod))
coef(mod)
names(coef(mod))
tau=c(0.1, 0.2)
mod <- rq(y ~ x, tau = tau)
names(coef(mod))
length(mod$tau)==1
rn <- rownames(coef(mod))
has_intercept <- tryCatch({
if(length(mod$tau)==1){
rn <- names(coef(mod))
}else{
rn <- rownames(coef(mod))
}
"(Intercept)" %in% rn
}, error = function(e) FALSE)
has_intercept
tau=c(0.1)
mod <- rq(y ~ x, tau = tau)
has_intercept <- tryCatch({
if(length(mod$tau)==1){
rn <- names(coef(mod))
}else{
rn <- rownames(coef(mod))
}
"(Intercept)" %in% rn
}, error = function(e) FALSE)
has_intercept
names(coef(mod))
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1)
x<-rnorm(100)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x, tau = tau)
res <- rankTest(mod = mod,  X = "x")
closedTesting(mod, X = "x")
tau=c(0.1, 0.2)
x<-rnorm(100)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x, tau = tau)
res <- rankTest(mod = mod,  X = "x")
closedTesting(mod, X = "x")
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
closedTesting(mod, X = "x")
mod <- rq(y ~ -1 +x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
LETTERS
x<-sample(LETTERS, 100)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
mod
summary(mod)
x
x<-sample(LETTERS, 100)
x
LETTERS
sample(LETTERS, 100)
x<-sample(LETTERS, 100, replace = TRUE)
x
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
x
summary(mod)
X
escape_rx <- function(x) gsub("([][{}()+*^$.|\\?\\\\])", "\\\\\\1", x)
escape_rx
model.frame(mod)
mod$model
summary(mod)
mod$x
tau
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
roxygen2::roxygenize()
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1, 0.2)
x<-sample(LETTERS, 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
mod
assert_binary_categorical_X(mod, "x")
assert_binary_categorical_X(mod, "x")
#Check
assert_intercept_present(mod = mod)
stats::model.frame(mod)
mf <- tryCatch(stats::model.frame(mod), error = function(e) NULL)
mf
!is.null(mf)
X %in% names(mf)
names(mf)
X
is.factor(mf[[X]])
nlevels(mf[[X]]) > 2L
# 2) Fallback: usa la matrice del modello per contare le colonne del termine X
trm <- tryCatch(stats::terms(mod), error = function(e) NULL)
if (!is.null(trm)) {
mm <- tryCatch(stats::model.matrix(trm, data = mf), error = function(e) NULL)
if (!is.null(mm)) {
tl <- attr(trm, "term.labels")
idx <- match(X, tl)
if (is.na(idx)) {
stop(sprintf("Covariate '%s' not found among model terms.", X), call. = FALSE)
}
# numero di colonne generate dal termine X
k <- sum(attr(mm, "assign") == idx)
# se >1 colonne e non posso verificare direttamente il tipo, assumo fattore multi-livello
if (k > 1L) {
stop(sprintf("The covariate '%s' appears to expand into %d columns. ",
X, k),
"Multilevel categorical covariates are not supported. ",
"Please recode it to a binary indicator.",
call. = FALSE)
}
return(invisible(TRUE))
}
}
roxygen2::roxygenize()
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1, 0.2)
x<-sample(LETTERS, 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
mod
is.character(X)
X
stopifnot(is.character(X), length(X) == 1L)
mf <- tryCatch(stats::model.frame(mod), error = function(e) NULL)
mf
!is.null(mf) && X %in% names(mf)
names(mf)
mf
mf[[X]]
xv <- mf[[X]]
is.factor(xv)
nlevels(xv) > 2L
!is.null(mf) && X %in% names(mf)
is.factor(xv) && nlevels(xv) > 2L
nlevels(xv)
xv
mf
mf[[X]]
mf
mf[["z"]]
mf[["x"]]
str(mf[["x"]])
str(mf[["z"]])
(is.character(xv) length(unique(xv))>1)
xv
is.character(xv)
is.character(xv)
length(unique(xv))
length(unique(xv))>2L
(is.character(xv) & length(unique(xv))>2L)
(is.factor(xv) && nlevels(xv) > 2L) | (is.character(xv) & length(unique(xv))>2L))
check_logical <- ((is.factor(xv) && nlevels(xv) > 2L) | (is.character(xv) & length(unique(xv))>2L))
check_logical
assert_binary_categorical_X <- function(mod, X) {
stopifnot(is.character(X), length(X) == 1L)
mf <- tryCatch(stats::model.frame(mod),
error = function(e) NULL)
if (!is.null(mf) && X %in% names(mf)) {
xv <- mf[[X]]
check_logical <- ((is.factor(xv) && nlevels(xv) > 2L) | (is.character(xv) & length(unique(xv))>2L))
if (check_logical) {
stop(sprintf(
"The covariate '%s' is a factor with %d levels. ",
X, nlevels(xv)
),
"This method only supports binary categorical covariates (â‰¤ 2 levels). ",
"Please recode it before fitting the model.",
call. = FALSE)
}
return(invisible(TRUE))
}
}
assert_binary_categorical_X(mod, "x")
nlevels(xv)
xv
roxygen2::roxygenize()
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1, 0.2)
x<-sample(LETTERS, 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
LETTERS[1:2]
x
summary(mod)
x<-sample(LETTERS[1:3], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
x <- as.factor(x)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
mod
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
res
mod
#Check
assert_intercept_present(mod = mod)
assert_binary_categorical_X(mod = mod, X = X)
tau
if(is.null(tau)){
tau <- mod$tau
}
if(sum(!(tau %in% mod$tau))!=0){
stop("Some quantiles specified are not the ones used in the quantile regression. Please specify a vector of proper quantiles.")
}
res <- estimateCovariance(mod = mod, X = X, test = "rank", h = h)
X
h
mod
res <- estimateCovariance(mod = mod, X = X, test = "rank", h = h)
taus <- mod$tau
density_list <- lapply(taus, function(tau) estimateDensity(mod = mod, tau, X = X, h = h, test = test))
density_list
f_quant_list <- lapply(density_list, function(x) 1/x)
design <- mod$x
formula <- make_h0_formula(mod = mod, X = X)
design_h0 <- rq(formula, tau=taus, data = mod$model)$x
x <- design[,(colnames(design) %in% c(X))]
hatz <-lapply(f_quant_list, function(w) design_h0%*%solve(t(design_h0)%*%diag(w)%*%design_h0)%*%t(design_h0)%*%diag(w)%*%x)
a <- lapply(taus, function(w) ranks(rq(formula, tau=-1, data = mod$model), score="tau", tau=w))
n <- nrow(design)
s <- mapply(function(w, u) n^(-0.5)*t(x-w)%*%(u$ranks), hatz, a, SIMPLIFY = FALSE)
Htaz <- do.call(cbind, hatz)
S <- unlist(s)
Z<-matrix(rep(x,length(taus)),n,length(taus))
M<-t(Z-Htaz)%*%(Z-Htaz)/n
ff<-Vectorize(function(x,y) {min(x,y)*(1-max(x,y))})
M<-t(Z-Htaz)%*%(Z-Htaz)/n
Htaz
Z
taus
Z<-matrix(rep(x,length(taus)),n,length(taus))
Z
x
colnames(design)
X
colnames(design) %in% c(X)
colnames(design)
mod$model
x <- design[,(colnames(mod$model) %in% c(X))]
x
hatz <-lapply(f_quant_list, function(w) design_h0%*%solve(t(design_h0)%*%diag(w)%*%design_h0)%*%t(design_h0)%*%diag(w)%*%x)
a <- lapply(taus, function(w) ranks(rq(formula, tau=-1, data = mod$model), score="tau", tau=w))
n <- nrow(design)
s <- mapply(function(w, u) n^(-0.5)*t(x-w)%*%(u$ranks), hatz, a, SIMPLIFY = FALSE)
Htaz <- do.call(cbind, hatz)
Htaz
S <- unlist(s)
Z<-matrix(rep(x,length(taus)),n,length(taus))
Z
M<-t(Z-Htaz)%*%(Z-Htaz)/n
ff<-Vectorize(function(x,y) {min(x,y)*(1-max(x,y))})
M2<-outer(taus,taus,FUN=ff)
M<-M*M2
roxygen2::roxygenize()
roxygen2::roxygenize()
tau=c(0.1, 0.2)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res
res <- waldTest(mod = mod,  X = "x")
res
assert_binary_categorical_X(mod, X)
if(is.null(tau)){
tau <- mod$tau
}
if(sum(!(tau %in% mod$tau))!=0){
stop("The quantiles specified are not the ones used in the quantile regression. Please specify a vector of proper quantiles.")
}
taus <- mod$tau
taus
coefest <- mod$coefficients[rownames(mod$coefficients) %in% X,]
coefest
mod$coefficients
rownames(mod$coefficients) %in% X
mod$coefficients
mod$coefficients
tau=c(0.1)
mod <- rq(y ~ x + z, tau = tau)
mod$coefficients
mod$model
library(quantreg)
library(quasar)
tau=c(0.1)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res
res <- waldTest(mod = mod,  X = "x")
res
tau=c(0.1, 0.2)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res
res <- waldTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
mod <- rq(y ~ x + z, tau = tau)
res <- waldTest(mod = mod,  X = "x")
mod
rownames(mod$model)
mod$model
ames(mod$model)
names(mod$model)
mod$coefficients
names(mod$model) %in% X
roxygen2::roxygenize()
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1, 0.2)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
res
x<-sample(LETTERS[1:3], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
closedTesting(mod, X = "x")
mod
tau
is.null(tau)
tau <- mod$tau
if(sum(!(tau %in% mod$tau))!=0){
stop("The quantiles specified are not the ones used in the quantile regression. Please specify a vector of proper quantiles.")
}
parse_set <- function(s) {
s <- gsub("[()\\s]", "", as.character(s))
as.numeric(strsplit(s, ",")[[1]])
}
res <- rankTest(mod = mod, X = X, tau = mod$tau, full = TRUE)
out <- data.frame(p.value.adjusted = NA,
quantiles.set = NA)
quantiles_single <- as.character(mod$tau)
quantiles_single
i = 1
idx <- vapply(res$Quantiles.Set, function(s) {
vals <- parse_set(s)
all(quantiles_single[i] %in% vals)
}, logical(1))
res_sub <- res[idx, ]
out[i,] <- c(max(res_sub$p.value),
quantiles_single[i])
for(i in seq(length(quantiles_single))){
idx <- vapply(res$Quantiles.Set, function(s) {
vals <- parse_set(s)
all(quantiles_single[i] %in% vals)
}, logical(1))
res_sub <- res[idx, ]
out[i,] <- c(max(res_sub$p.value),
quantiles_single[i])
}
length(mod$tau)==1
out$quantiles.set
roxygen2::roxygenize()
roxygen2::roxygenize()
library(quantreg)
library(quasar)
tau=c(0.1, 0.2)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
closedTesting(mod, X = "x")
x<-sample(LETTERS[1:3], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
closedTesting(mod, X = "x")
tau=c(0.1)
x<-sample(LETTERS[1:2], 100, replace = TRUE)
z<-rnorm(100)
y<-rnorm(100)
mod <- rq(y ~ x + z, tau = tau)
res <- rankTest(mod = mod,  X = "x")
res <- waldTest(mod = mod,  X = "x")
res
res <- rankTest(mod = mod,  X = "x")
res
closedTesting(mod, X = "x")
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
p <- 3; Sigma <- diag(p)
dat_n <- simulateData(200, beta=0, gamma=c(0.2,-0.1), mu=0,
Sigma=Sigma, sigma.y=0.5, distribution="normal")
dat_n <- simulateData(200, beta=0, gamma=c(0.2,-0.1), mu=4,
Sigma=Sigma, sigma.y=0.5, distribution="normal")
head(dat_n)
mod <- rq(y ~ x + Z1 + Z2, tau = tau,data = dat_n)
mod <- rq(y ~ X + Z1 + Z2, tau = tau, data = dat_n)
tau
mod <- rq(y ~ X + Z1 + Z2, tau = c(0.1, 0.25, 0.5, 0.75, 0.9), data = dat_n)
summary(mod)
closedTesting(mod, X = "x")
closedTesting(mod, X = "X")
dat_n <- simulateData(200, beta=0.5, gamma=c(0.2,-0.1), mu=4,
Sigma=Sigma, sigma.y=0.5, distribution="normal")
mod <- rq(y ~ X + Z1 + Z2, tau = c(0.1, 0.25, 0.5, 0.75, 0.9), data = dat_n)
closedTesting(mod, X = "X")
dat_n <- simulateData(200, beta=0.1, gamma=c(0.2,-0.1), mu=4,
Sigma=Sigma, sigma.y=0.5, distribution="normal")
mod <- rq(y ~ X + Z1 + Z2, tau = c(0.1, 0.25, 0.5, 0.75, 0.9), data = dat_n)
closedTesting(mod, X = "X")
dat_n <- simulateData(200, beta=0.2, gamma=c(0.2,-0.1), mu=4,
Sigma=Sigma, sigma.y=0.5, distribution="t")
mod <- rq(y ~ X + Z1 + Z2, tau = c(0.1, 0.25, 0.5, 0.75, 0.9), data = dat_n)
closedTesting(mod, X = "X")
dat_n <- simulateData(200, beta=0, gamma=c(0.2,-0.1), mu=4,
Sigma=Sigma, sigma.y=0.5, distribution="t")
mod <- rq(y ~ X + Z1 + Z2, tau = c(0.1, 0.25, 0.5, 0.75, 0.9), data = dat_n)
closedTesting(mod, X = "X")
devtools::check()
devtools::check()
x <- c(2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00, 10.00)
px <- c(0.08, 0.14, 0.20, 0.25, 0.12, 0.09, 0.06, 0.04, 0.02)
sum(x*px)
sum((x^2)*px)
sum(x*px)^2
28.84 - sum(x*px)^2
x^2
x^2*px
sum(x^2*px)
28.84- 25.2004
x <- c(0.00, 2.00, 3.00, 4.00 ,5.00, 6.00, 7.00, 8.00, 9.00)
px <- c(0.05, 0.22, 0.22, 0.17, 0.1, 0.05, 0.02, 0.01, 0.16)
sum(x*px)
sum(x^2*px)
sum(x^2*px) - 4.24^2
quasar::simulateDate
